---
title: "Stan and Torsten"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Issues in using Torsten
We had difficulties when calling Torsten built-in functions via rstan package due to the recent updates in Torsten functions. These features are updated to Stan version 2.19.1.

### Function names
According to a recent github post, the following functions are renamed:

-   `PKModelOneCpt` &rarr; `pmx_solve_onecpt`\n
-   `PKModelTwoCpt` &rarr; `pmx_solve_twocpt`\n
-   `linOdeModel` &rarr; `pmx_solve_linode`\n
-   `generalOdeModel_adams` &rarr; `pmx_solve_adams`\n
-   `generalOdeModel_bdf` &rarr; `pmx_solve_bdf`\n
-   `generalOdeModel_rk45` &rarr; `pmx_solve_rk45`\n
-   `mixOde1CptModel_bdf` &rarr; `pmx_solve_onecpt_bdf`\n
-   `mixOde1CptModel_rk45` &rarr; `pmx_solve_onecpt_rk45`\n
-   `mixOde2CptModel_bdf` &rarr; `pmx_solve_twocpt_bdf`\n
-   `mixOde2CptModel_rk45` &rarr; `pmx_solve_twocpt_rk45`\n

### Returned matrix dimension
The new version of the above functions return the *transpose* of the matrix returned by the old versions. 

##Update the Stan model script
To call Torsten built-in functions, we need to update the function names and the dimension of output matrix. We will show you two examples. The two examples can be found here: https://www.metrumrg.com/course/advanced-use-stan-rstan-torsten-pharmacometric-applications/.

###multi-Dose PK1 example
In the original 'multiDosePK1Torsten.stan' script, function 'PKModelOneCpt' is called in 'transformed parameters' module and 'generated quantities' module. 

We need to update the dimension of x and the name of the function. ' is a transpose operation.

The original code in 'transformed parameters' module is:
```{stan eval=FALSE, include=T, output.var="A"}
matrix[nt, nCmt] x;
```

```{stan eval=FALSE, include=T, output.var="A"}
x[start[j]:end[j],] = PKModelOneCpt(time[start[j]:end[j]], 
					amt[start[j]:end[j]],
					rate[start[j]:end[j]],
					ii[start[j]:end[j]],
					evid[start[j]:end[j]],
					cmt[start[j]:end[j]],
					addl[start[j]:end[j]],
					ss[start[j]:end[j]],
					parms, F, tLag);
					
    cHat[start[j]:end[j]] = x[start[j]:end[j], 2] ./ V[j];
```

Now, update them to
```{stan eval=FALSE, include=T, output.var="A"}
//matrix[nt, nCmt] x;
matrix[nCmt, nt] x;
```

```{stan eval=FALSE, include=T, output.var="A"}
//x[start[j]:end[j],] = PKModelOneCpt(time[start[j]:end[j]], 
  x[,start[j]:end[j]] = pmx_solve_onecpt(time[start[j]:end[j]], 
					amt[start[j]:end[j]],
					rate[start[j]:end[j]],
					ii[start[j]:end[j]],
					evid[start[j]:end[j]],
					cmt[start[j]:end[j]],
					addl[start[j]:end[j]],
					ss[start[j]:end[j]],
					parms, F, tLag);
    //cHat[start[j]:end[j]] = x[start[j]:end[j], 2] ./ V[j];
    cHat[start[j]:end[j]] = (x[2, start[j]:end[j]] ./ V[j])';
```

The original code in 'generated quantities' module is:
```{stan eval=FALSE, include=T, output.var="A"}
matrix[nt, nCmt] xPred;
```

```{stan eval=FALSE, include=T, output.var="A"}
xPred[start[j]:end[j],] = PKModelOneCpt(time[start[j]:end[j]], 
					    amt[start[j]:end[j]],
					    rate[start[j]:end[j]],
					    ii[start[j]:end[j]],
					    evid[start[j]:end[j]],
					    cmt[start[j]:end[j]],
					    addl[start[j]:end[j]],
					    ss[start[j]:end[j]],
					    parmsPred, F, tLag);

    cHatPred[start[j]:end[j]] = xPred[start[j]:end[j], 2] ./ VPred[j];
```

Now, update the codes to
```{stan eval=FALSE, include=T, output.var="A"}
//matrix[nt, nCmt] xPred;
 matrix[nCmt, nt] xPred;
```

```{stan eval=FALSE, include=T, output.var="A"}
//xPred[start[j]:end[j],] = PKModelOneCpt(time[start[j]:end[j]], 
  xPred[,start[j]:end[j]] = pmx_solve_onecpt(time[start[j]:end[j]], 
					    amt[start[j]:end[j]],
					    rate[start[j]:end[j]],
					    ii[start[j]:end[j]],
					    evid[start[j]:end[j]],
					    cmt[start[j]:end[j]],
					    addl[start[j]:end[j]],
					    ss[start[j]:end[j]],
					    parmsPred, F, tLag);

    //cHatPred[start[j]:end[j]] = xPred[start[j]:end[j], 2] ./ VPred[j];
    cHatPred[start[j]:end[j]] = (xPred[2,start[j]:end[j]] ./ VPred[j])';
```


###neutropenia example
In the original neutropeniaSinglePatient1.stan script, function 'PKModelOneCpt' is called in 'transformed parameters' module. The original code is:

```{stan eval=FALSE, include=T, output.var="A"}
matrix[nt, 8] x;
```

```{stan eval=FALSE, include=T, output.var="A"}
x = generalOdeModel_rk45(twoCptNeutModelODE, 8,
			   time, amt, rate, ii, evid, cmt, addl, ss,
			   parms, F, tLag,1e-6, 1e-6, 1e8);

  cHat = x[ ,2] / V1;
  neutHat = x[,8] + circ0;
```

Update the dimension of x and the name of the function to
```{stan eval=FALSE, include=T, output.var="A"}
//matrix[nt, 8] x;
matrix[8, nt] x;
```

```{stan eval=FALSE, include=T, output.var="A"}
//x = generalOdeModel_rk45(twoCptNeutModelODE, 8,
x = pmx_solve_rk45(twoCptNeutModelODE, 8,
			   time, amt, rate, ii, evid, cmt, addl, ss,
			   parms, F, tLag,1e-6, 1e-6, 1e8);
  
  //cHat = x[ ,2] / V1;
  cHat = (x[2, ] / V1)';
  
  //neutHat = x[,8] + circ0;
  neutHat = (x[8, ])' + circ0;
```


## Using 'cmdstanr' instead of 'rstan'
Currently, a few Stan new features can only be used via 'cmdstanr'. It is easy to convert the modeling codes from 'rstan' to 'cmdstanr' and convert the output back to a 'stanfit'.

###multi-Dose PK1 example
The following is the stan fit code in multiDosePK1.R
```{r eval=F,echo=T}
fit <- stan(file = "multiDosePK1Torsten.stan",
            data = data,
            pars = parameters,
            iter = nIter,
            warmup = nBurnin,
            thin = nThin, 
            init = init,
            chains = nChains,
            control = list(adapt_delta = 0.9))
```

Now load 'cmdstanr' package:
```{r eval=F,echo=T}
library(cmdstanr)
set_cmdstan_path(path = "/pkpd/Torsten/cmdstan")
```
Make sure the cmdstan path is given correctly. Then, the cmdstan fit codes are:
```{r eval=F,echo=T}
nsample <- nIter - nBurnin #added for cmdstanr
mod <- cmdstan_model("multiDosePK1Torsten.stan", quiet=T)    
fit.cmdstan <- mod$sample(data = data,
                      init = init,
                      chains = nChains,
                      parallel_chains = min(nChains, detectCores()),
                      iter_warmup = nBurnin,
                      iter_sampling = nsample,
                      thin = nThin)                               
```

Convert the output to a stan fit
```{r eval=F,echo=T}
fit <- rstan::read_stan_csv(fit.cmdstan$output_files())                     
```


###neutropenia example
In neutropeniaSinglePatient1.R, neutropeniaSinglePatient1Sim.stan is used to simulate the observations:
```{r eval=F,echo=T}
sim <- stan(file = "neutropeniaSinglePatient1Sim.stan",
  data = dataSim,
  algorithm = "Fixed_param",
  iter = 1,
  chains = 1)
```
Convert it to cmdstan modeling codes and convert the output to a stan fit:
```{r eval=F,echo=T}
mod.sim <- cmdstan_model("neutropeniaSinglePatient1Sim.stan", quiet=T)
sim.cmdstan <- mod.sim$sample(data = dataSim,
                          fixed_param = TRUE,
                          iter_warmup = 0,
                          iter_sampling = 1,
                          chains = 1)
sim <- read_stan_csv(sim.cmdstan$output_files())
```

When simulating the MCMC chains, the rstan codes are
```{r eval=F,echo=T}
fit <- stan(file = "neutropeniaSinglePatient1.stan",
            data = data,
            pars = parameters,
            iter = nIter,
            warmup = nBurnin,
            thin = nThin, 
            init = init,
            chains = nChains,
            cores = nChains,
            refresh = 10,
            control = list(adapt_delta = 0.95, stepsize = 0.01))
```
Convert it to cmdstan modeling codes and convert the output to a stan fit:
```{r eval=F,echo=T}
nSample <- nIter - nBurnin
mod <- cmdstan_model("neutropeniaSinglePatient1.stan", quiet=T)
fit.cmdstan <- mod$sample(data = data,
                      refresh = 10,
                      init = init,
                      chains = nChains,
                      parallel_chains = min(nChains, detectCores()),
                      iter_warmup = nBurnin,
                      iter_sampling = nSample,
                      thin = nThin)

fit <- read_stan_csv(fit.cmdstan$output_files())
```
##Results from Torsten built-in function 
Here we compare the results from the Stan models that use Torsten functions and the Stan models that do not.

###multi-Dose PK1 example
\n
The estimates from multiDosePK1.stan:
```{r echo=FALSE}
tab1 <- read.csv("C://advancedStanYouTube/multiDosePK1ParameterTable.csv")
rownames(tab1) <- tab1$X
tab1 <- tab1[-1]
knitr::kable(round(tab1,5))
```
\n
The estimates from multiDosePK1Torsten.stan:
```{r echo=FALSE}
tab2 <- read.csv("C://advancedStanYouTube/multiDosePK1TorstenParameterTable.csv")
rownames(tab2) <- tab2$X
tab2 <- tab2[-1]
knitr::kable(round(tab2,5))
```

\n
The prediction plots from multiDosePK1 (left) and multiDosePK1Torsten (right)

```{r, out.width = "45%", echo=FALSE}
# two figs side by side
knitr::include_graphics(c("C://advancedStanYouTube/multiDosePK1Plots008-1.png",
                   "C://advancedStanYouTube/multiDosePK1TorstenPlots008-1.png"))
```

  
  
```{r, out.width = "45%", echo=FALSE}
# two figs side by side
knitr::include_graphics(c("C://advancedStanYouTube/multiDosePK1Plots009-1.png",
                   "C://advancedStanYouTube/multiDosePK1TorstenPlots009-1.png"))
```

###neutropenia example
There is another neutropenia Stan model that does not require a Torsten function (https://github.com/stan-dev/stancon_talks/tree/master/2017/Contributed-Talks/05_margossian/models/neutropenia). We used the Torsten version neutropenia model and the non-Torsten neutropenia model for the same data to compare the two models.
\n
The estimates from multiDosePK1.stan:
```{r echo=FALSE}
tab1 <- read.csv("C://advancedStanYouTube/neutropeniaParameterTable.csv")
rownames(tab1) <- tab1$X
tab1 <- tab1[-1]
knitr::kable(round(tab1,5))
```
\n
The estimates from multiDosePK1Torsten.stan:
```{r echo=FALSE}
tab2 <- read.csv("C://advancedStanYouTube/neutropeniaSinglePatient1ParameterTable.csv")
rownames(tab2) <- tab2$X
tab2 <- tab2[-1]
knitr::kable(round(tab2,5))
```
\n
The prediction of CObs (top) and NeutObs (bottom) from non-Torsten neutropenia (left) and Torsten neutropenia (right). CObs and NeutObs are the same for the two models.\n

```{r, out.width = "45%", echo=FALSE}
# two figs side by side
knitr::include_graphics(c("C://advancedStanYouTube/neutropeniapred1.png",
                   "C://advancedStanYouTube/neutropeniaSinglePatient1pred1.png"))
```
```{r, out.width = "45%", echo=FALSE}
# two figs side by side
knitr::include_graphics(c("C://advancedStanYouTube/neutropeniapred2.png",
                   "C://advancedStanYouTube/neutropeniaSinglePatient1pred2.png"))
```